\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage[plain]{fancyref}

\begin{document}

\title{A Reasonably Fast and Fully Capable JVM in JavaScript}

\numberofauthors{4}
\author{
\alignauthor Michael Bebenita
\alignauthor Brendan Dahl
\and
\alignauthor Marco Castelluccio
\alignauthor Myk Melez
\and
\alignauthor Andreas Gal
}

\maketitle
\begin{abstract}
Dramatic improvements in browser performance have now made JavaScript a viable compilation target for a wide range of programming languages.
While targetting JavaScript is fairly easy, navigating optimization tiers wrapped in arcane magic and mystery make squeezing performance out of modern JavaScript engines incredibly difficult.
In this paper we explore the implementation of a fully capable Java virtual machine in JavaScript.
One that supports: class loading, interpretation, dynamic compilation, on-stack-replacement, deoptimization, threading, synchronization, garbage collection, finalization, many of the other features that make Java, Java.
\end{abstract}

% \category{D.3.4}{Programming Languages}{Processors}

\terms{Languages, Design}

\keywords{ACM proceedings, \LaTeX, text tagging}

\section{Introduction}

Like it or not, JavaScript is the de facto lingua franca. ...
Lots of attempts at compiling to the web, C/C++ via Emscripten has be highly successful.
Java attempts have not been as successful, too slow, large code size.
Java needs class loading, it needs faster startup, low 
We believe compiling Java to JavaScript should be faster than writing JavaScript by hand.

The web pptimize for size and startup, not throughput.

\section{System Constraints}

In JavaScript you can't do this and that. No threads, no weak references, you can't do synch I/O, etc. ...
In JavaScript you have to pay for your cake before you eat it, vm code size matters.

\section{Motivation}



\section{Implementation}

\subsection{Class Loading}

Before the JVM can execute any code it must first load it.
Java classes are packaged in \texttt{.class} files and stored compressed in archive \texttt{.jar} files.
Decompressing \texttt{.jar} files is the first step in building a JVM in JavaScript and the first sign of the troubles ahead.

\subsubsection{GZip}

Archive files typically use the \texttt{DEFLATE} algorithm.
There are many JavaScript implementations of this algorithm, but none that we've been satisfied with in terms of performance.
...

\subsubsection{Class File Representation}

The most obvious way to deal with Java \texttt{.class} files is to parse them into a JavaScript friendly object graph.
This is convenient but it has several severe disadvantages:
\begin{enumerate}
\item The \texttt{.class} file structure is directly accessible and doesn't need to be parsed ahead-of-time.
Parsing introduces a significant latency delay and should be deferred as long much as possible. 
\item The \texttt{.class} file structure is compact. Reflecting this into an JavaScript object graph more than doubles the size of the data structure.
\end{enumerate}

To work around these limitations and still provide a convenient way to represent \texttt{.class} files, we create views on the underlying \texttt{.class} file buffer.
Access to most properties is performed via accessor getters that lazily construct additionaly subviews as needed.
The advantage of this approach is that most of the data is kept in the original buffer and never reflected into JavaScript properties.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=200px]{classInfo.pdf}
\caption{ClassInfo TypedArray Views}
\label{default}
\end{center}
\end{figure}

\subsubsection{Strings}

While it is tempting to reflect Java strings as JavaScript strings, it turns out that it is a lot more effective to keep them in their original representation.
Strings in modern JavaScript engines are heavily optimized.
Taking advantage of this fact seems like a good idea at first, not only for convenience but also for performance reasons.
Unfortunately reflecting Java strings as JavaScript strings causes a lot of unintended consequences:

\begin{enumerate}
\item Java \texttt{.class} files use a slightly modified UTF-8 string encoding scheme.
Decoding this scheeme is inefficient because JavaScript provides no efficient means of constructing strings from UTF-8 sequences.
More importantly, it is often unnecessary.
Most of the strings that appear in \texttt{.class} files are used for linking where comparisons and hashing are by far the most frequent operations.
Both of these operations are faster to implement on the original string representation and don't require UTF-8 decoding.
\item Java \texttt{.class} files contain a large number of strings, storing them in two different formats can take up a significant amount of memory.
\item Java's \texttt{String} class manages an internal \texttt{char []} array of characters.
This encoding is different from the encoding in the \texttt{.class} file but it would still need an associated JavaScript string to be kept in sync with the underlying char buffer.
\item Holding on to references to JavaScript objects from Java objects constrains the design of the Java object layout, as later described in \fref{sec:objectLayout}.
\end{enumerate}

\subsection{Stack Layout}

\subsection{Object Layout} \label{sec:objectLayout}

\subsubsection{Object Arrays}

\subsubsection{Typed Arrays}

\subsection{Interpreter}

\subsubsection{Switch Loop}

\subsubsection{Hosted Interpreter}

\subsection{Interpreter}

\subsection{Just-in-Time Compiler}

\subsubsection{Relooper}

\subsection{Threading}

A JVM that needs to run even mildly sophisticated applications must implement threads.
Java threads are typically implemented using the underlying operating system's threads.
JavaScript does not have access to the operating system's raw threads, but it does allow for concurrent programming with the use of web workers which are a similar concept to threads, but differ in key ways.
Each web worker runs in its own isolated execution context and can only share data through a copying message passing system.
Web workers also follow JavaScript's run-to-completion execution model with an event loop, which makes it impossible to lock or wait on another web worker.
With the aforementioned limitations of web workers our VM instead emulates threads entirely in the main JavaScript event loop.
This allows us to share data easily, but it still comes with a number of challenges.

Footnote:???In the future web workers may be a viable option to emulate threading with the advent of shared array buffers, but at the time of creating our VM no browsers supported this option.

\subsubsection{Asynchronous I/O, Synchronization, and Context Switching}

\subsubsection{Scheduling}

\subsection{On-Stack-Replacement}

\subsection{Garbage Collection}

\subsection{Performance Tuning}

\subsubsection{Startup Speed}

\subsubsection{Memory Usage}

\subsection{Host VM Tuning}

\subsection{Citations}

\subsection{Evaluation}

\section{Related Work}

\section{Conclusions}

\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case

\end{document}
